#!/bin/bash
## usync ::

print_help() { cat <<'HELPDOC'
NAME
    usync - push/pull changes from remote source

SYNOPSIS
    usync <command> [option...]

DESCRIPTION
    Usync is an rsync wrapper controlled by a simple config file. Usync
    searches the current and parent directories for a .usync file that defines
    a remote rsync host. COMMAND is executed in root directory containing
    .usync file.

COMMANDS
    init
        Create a new .usync file in current directory.

    push
        Push changes to remote source.

    pull
        Pull changes from remote source.

OPTIONS
    -c, --config <FILE>
        Use config FILE.

    -d, --dir <DIRECTORY>
        Set remote directory.

    -e, --exclude <PATTERN>
        Add to exclude patterns.

    -p, --port <PORT>
        Set port number.

    -r, --remote, --url <URL>
        Set remote url.

    -u, --user <USER>
        Set remote user.

    -D, --dryrun
        Perform dry run making no changes.

    -Q, --quiet
        Don't write anything to stdout.

    -V, --verbose
        Show rsync command.

    --nocolor
        Disable colored output.

    -H, --help
        Print help.

CONFIG
    .usync - yaml file containing the following keys:

        dir
            Remote repo directory. Must be a full path. (required)

        remote or url
            Remote repo url. May be an ssh alias. (optional)

        port
            Remote port. (optional)

        user
            Remote user. (optional)

        exclude
            List of patterns to exclude via rsync --exclude option. (optional)
            See FILTER RULES section of rsync manual for details and syntax.

ENVIRONMENT
    NOCOLOR=1
        Disable colored output.

    QUIET=1
        Run silently

    VERBOSE=1
        Run verbosely.

REQUIREMENTS
    rsync, ssh
HELPDOC
}
[[ "$0" != "$BASH_SOURCE" ]] && print_help && return 0

## settings ::
readonly deps=(rsync ssh)
readonly opts=(init pull push -c: --config: -d: --dir: -e: --exclude: -p: --port: -r: --remote: --url: -u: --user: -D --dryrun -Q --quiet -V --verbose --debug --nocolor -H --help)

# defaults:
DEBUG="${DEBUG:-0}"
NOCOLOR="${NOCOLOR:-0}"
QUIET="${QUIET:-0}"
VERBOSE="${VERBOSE:-0}"

## internal functions/variables ::
readonly args=("$@")
args_operands=()
args_options=()
args_parsed=()
conf='.usync'
dir=
dryrun=0
excludes=()
host="$HOSTNAME"
in_exclude=0
init=0
opt_dir=
opt_port=
opt_remote=
opt_user=
port=
pull=0
push=0
remote_dir=
remote='localhost'
rsync_args=(-azz --protect-args --info=copy1,del1,name1 --delete)
sed_args=()
user=

# colors:
blue=$'\e[38;5;12m'
bold=$'\e[1m'
green=$'\e[38;5;10m'
off=$'\e[0m'
red=$'\e[38;5;9m'
white=$'\e[38;5;15m'
yellow=$'\e[38;5;11m'
if tput setaf 0 &>/dev/null; then
    blue="$(tput setaf 12)"
    bold="$(tput bold)"
    green="$(tput setaf 10)"
    off="$(tput sgr0)"
    red="$(tput setaf 9)"
    white="$(tput setaf 15)"
    yellow="$(tput setaf 11)"
fi
clear_colors() { unset blue bold green off red white yellow ;}

# messages:
msg() { ((QUIET)) && return; printf "$bold$blue=> $off$white$1$off\n" "${@:2}" ;}
msg2() { ((QUIET)) && return; printf "$bold$blue > $off$white$1$off\n" "${@:2}" ;}
msg_debug() { ((DEBUG)) && printf "$yellow$BASH_LINENO: $off$1\n" "${@:2}" ;}
msg_error() { printf "$bold${red}E: $off$white$1$off\n" "${@:2}" >&2 ;}
msg_warn() { printf "$bold${yellow}W: $off$white$1$off\n" "${@:2}" >&2 ;}
msg_good() { ((QUIET)) && return;printf "$bold$green=> $off$white$1$off\n" "${@:2}" ;}
msg_cmd() {
    ((QUIET)) && return
    [[ $EUID -eq 0 ]] && printf "$bold$red #" || printf "$bold$blue $"
    printf "$off$white"; printf ' %q' "$@"; printf "$off\n"
}

# errors:
error() { msg_error "$@"; exit 3 ;}
error_opt() { error "unrecognized option: $1" "${@:2}" ;}
error_optarg() { error "option requires an argument: $1" "${@:2}" ;}
error_flg() { error "option does not take argument: $1" "${@:2}" ;}

# tests:
is_cmd() { command -v "$1" &>/dev/null ;}
is_img() { [[ -f "$1" ]] && identify "$1" &>/dev/null ;}

# commands:
cmd() { ((VERBOSE)) && msg_cmd "$@"; "$@" ;}
input() { read -erp $'\e[1;38;5;10m''> '$'\e[0;38;5;15m'"$1 "$'\e[0m' "$2" ;}

# arg parser:
parse_args() {
    local a=0 opt= sflgs= sopts= arg="${args[0]}"
    local -a lflgs=() lopts=()
    for opt in "${opts[@]}"; do case "$opt" in
        -?) sflgs="$sflgs${opt:1}" ;;
        -?:) sopts="$sopts${opt:1:1}" ;;
        *:) lopts+=("${opt:0:-1}") ;;
        *) lflgs+=("$opt") ;;
    esac; done
    while [[ -n "$arg" ]]; do
        case "$arg" in
            --) ((a++)); break ;;
            -[$sflgs]) args_parsed+=("$arg") ;;
            -[$sflgs]*)
                [[ "$sflgs$sopts" =~ "${arg:2:1}" ]] || error_opt "-${arg:2:1}"
                args_parsed+=("${arg:0:2}"); arg="-${arg:2}"; continue ;;
            -[$sopts])
                [[ $((${#args[@]}-a)) -le 1 ]] && error_optarg "$arg"
                args_parsed+=("$arg" "${args[((++a))]}") ;;
            -[$sopts]*) args_parsed+=("${arg:0:2}" "${arg:2}") ;;
            *=*)
                [[ " ${lflgs[*]} " =~ " ${arg%%=*} " ]] && error_flg "${arg%%=*}"
                [[ " ${lopts[*]} " =~ " ${arg%%=*} " ]] || break
                args_parsed+=("${arg%%=*}" "${arg#*=}") ;;
            *)
                if [[ " ${lflgs[*]} " =~ " $arg " ]]; then
                    args_parsed+=("$arg")
                elif [[ " ${lopts[*]} " =~ " $arg " ]]; then
                    [[ ${#args[@]} -le $((a+1)) ]] && error_optarg "$arg"
                    args_parsed+=("$arg" "${args[((++a))]}")
                else break; fi ;;
        esac
        arg="${args[((++a))]}"
    done
    args_options=("${args_parsed[@]}")
    args_operands=("${args[@]:a}")
    args_parsed+=('--' "${args[@]:a}")
}

## main ::
trap exit INT
[[ ! -t 1 || ! -t 2 ]] || ((NOCOLOR)) && clear_colors

# parse args:
msg_debug "args=($(printf '%q ' "${args[@]}"))"
parse_args
set -- "${args_options[@]}"
while [[ -n "$1" ]]; do case "$1" in
    init) init=1 ;;
    pull) pull=1 ;;
    push) push=1 ;;
    -c|--config) shift; conf="$1" ;;
    -d|--dir) shift; opt_dir="$1" ;;
    -e|--exclude) shift; excludes+=("$1") ;;
    -p|--port) shift; opt_port="$1" ;;
    -r|--url|--remote) shift; opt_remote="$1" ;;
    -u|--user) shift; opt_user="$1" ;;
    -D|--dryrun) dryrun=1 ;;
    -Q|--quiet) QUIET=1; VERBOSE=0 ;;
    -V|--verbose) QUIET=0; VERBOSE=1 ;;
    --debug) DEBUG=1 ;;
    --nocolor) clear_colors ;;
    -H|--help) print_help; exit 0 ;;
esac; shift; done
msg_debug "args_parsed=($(printf '%q ' "${args_parsed[@]}"))"

# errors:
for d in "${deps[@]}"; do is_cmd "$d" || error "missing dependency: $d"; done
[[ ${#args_operands[@]} -gt 0 ]] && error_opt "${args_operands[0]}"
((init+push+pull-1)) && error 'too many commands'
! ((init+push+pull)) && msg_warn 'no command' && exit 0

if ((init)); then
    # create new .usync file in current directory:
    [[ -f "$conf" ]] && error "already exists: $conf"
    touch "$conf"
    { printf '## %s ::\n\n' "$(realpath "$conf")"
    printf 'dir: %s\n' "${opt_dir:-$PWD}"
    printf 'url: %s\n' "${opt_remote:-$remote}"
    [[ -n "$opt_port" ]] && printf 'port: %s\n' "$opt_port"
    [[ -n "$opt_user" ]] && printf 'user: %s\n' "$opt_user"
    printf 'exclude:\n- .git\n- /local\n'
    for e in "${excludes[@]}"; do printf '%s %s\n' '-' "$e"; done
    printf '\n# vim:ft=yaml\n' ;} > "$conf"
    exit 0
fi

# cd to nearest parent directory that contains config file:
while [[ ! -f "$conf" && "$PWD" != '/' ]]; do cd ..; done
[[ ! -f "$conf" ]] && error "$conf not found"

# parse config:
mapfile -t lines < <(sed -E -e 's/(^\s+|\s+$)//g' -e '/^(#|$|-$)/d' "$conf")
in_exclude=0
for l in "${lines[@]}"; do
    if ((in_exclude)); then
        [[ "$l" =~ ^-\ +(.*) ]] && excludes+=("${BASH_REMATCH[1]}") && continue
        in_exclude=0
    fi
    [[ "$l" =~ ^dir:\ +(.*) ]] && dir="${BASH_REMATCH[1]}" && continue
    [[ "$l" =~ ^port:\ +(.*) ]] && port="${BASH_REMATCH[1]}" && continue
    [[ "$l" =~ ^url:\ +(.*) ]] && remote="${BASH_REMATCH[1]}" && continue
    [[ "$l" =~ ^remote:\ +(.*) ]] && remote="${BASH_REMATCH[1]}" && continue
    [[ "$l" =~ ^user:\ +(.*) ]] && user="${BASH_REMATCH[1]}" && continue
    [[ "$l" == exclude: ]] && in_exclude=1 && continue
done
dir="${opt_dir:-$dir}"
port="${opt_port:-$port}"
remote="${opt_remote:-$remote}"
user="${opt_user:-$user}"

# replace leading ~ with $HOME and remove trailing / from dir:
[[ "${dir:0:1}" = '~' ]] && dir="$HOME${dir:1}"
[[ "${dir: -1}" = '/' ]] && dir="${dir:0:-1}"

# config errors:
[[ -z "$remote" ]] && error 'no remote'
[[ -z "$dir" ]] && error 'no directory'
[[ -n "$port" && (! "$port" =~ ^[1-9][0-9]*$ || $port -gt 65535) ]] && error "invalid port: $port"

# resolve host and remote:
[[ -f /etc/hostname ]] && host="$(cat /etc/hostname)"
[[ -f /etc/hostname- ]] && host="$(cat /etc/hostname-)"
[[ "$remote" =~ ^(|$host|127.0.0.1)$ ]] && remote='localhost'

# debug info:
msg_debug "dir=$dir port=$port remote=$remote user=$user"
msg_debug "excludes=(${excludes[*]})"

# set remote_dir and add user/port to rsync ssh command:
remote_dir="$dir"
if [[ "$remote" == localhost ]]; then
    # dir is a file:
    [[ -f "$dir" ]] && error "not a directory: $dir"
    # inside remote:
    if [[ -d "$dir" && "$(realpath "$dir")" = "$(realpath "$PWD")" ]]; then
        msg_warn 'remote repo: no action taken'; exit 0
    fi
else
    remote_dir="$remote:$dir"
    if [[ -n "$port" || -n "$user" ]]; then
        rsync_args+=('-e' "ssh${port:+ -p $port}${user:+ -l $user}")
    fi
fi

# add excludes to rsync args:
for e in "${excludes[@]}"; do rsync_args+=('--exclude' "$e"); done

# add --dry-run to rsync args and set output colors:
if ((dryrun)); then
    rsync_args+=('--dry-run')
    sed_args=(-e "s/deleting /$bold$yellow - $off$white/" -e "/ - /! s/^/$bold$yellow + $off$white/")
else
    sed_args=(-e "s/deleting /$bold$red - $off$white/" -e "/ - /! s/^/$bold$green + $off$white/")
fi

# set rsync push/pull args:
if ((push)); then
    msg 'pushing %q to %q ...' "$PWD/" "$remote_dir/"
    if [[ "$remote" == localhost ]]; then
        # create local directory:
        if [[ ! -d "$dir" ]] && ! ((dryrun)); then
            cmd mkdir -p "$dir"
        fi
    elif ! ((dryrun)); then
        # create remote directory:
        rsync_args+=('--rsync-path' "mkdir -p '$dir' && rsync")
    fi
    rsync_args+=("$PWD/" "$remote_dir")
elif ((pull)); then
    msg 'pulling %q from %q ...' "$PWD/" "$remote_dir/"
    rsync_args+=("$remote_dir/" "$PWD")
fi

# rsync:
((VERBOSE)) && msg_cmd rsync "${rsync_args[@]}"
if ((QUIET)); then
    rsync "${rsync_args[@]}" 1>/dev/null
else
    rsync "${rsync_args[@]}" | sed -Ee '/\/$/d' -e '/^created /d' "${sed_args[@]}"
fi

# dryrun warning:
((dryrun)) && msg_warn 'dryrun'

# vim:ft=bash
