#!/bin/bash
## usync ::

print_help() { cat <<'HELPDOC'
NAME
    usync - push/pull changes from remote source

SYNOPSIS
    usync <COMMAND> [OPTION...]

DESCRIPTION
    Usync is an rsync wrapper controlled by a simple config file. Usync
    searches the current and parent directories for a .usync file that defines
    a remote rsync host. COMMAND is executed in root directory containing
    .usync file.

COMMANDS
    init
        Create a new .usync file in current directory.

    push
        Push changes to remote source.

    pull
        Pull changes from remote source.

OPTIONS
    -c, --config <FILE>
        Use config FILE.

    -d, --dir <DIRECTORY>
        Set remote directory.

    -e, --exclude <PATTERN>
        Add to exclude patterns.

    -p, --port <PORT>
        Set port number.

    -r, --url, --remote <URL>
        Set remote url.

    -u, --user <USER>
        Set remote user.

    -D, --dryrun
        Perform dry run making no changes.

    -V, --verbose
        Print shell commands.

    -H, --help
        Display this help.

CONFIG
    .usync - yaml file containing the following keys:

        dir
            Remote repo directory. Must be a full path. (required)

        remote or url
            Remote repo url. May be an ssh alias. (optional)

        port
            Remote port. (optional)

        user
            Remote user. (optional)

        exclude
            List of patterns to exclude via rsync --exclude option. (optional)
            See FILTER RULES section of rsync manual for details and syntax.

REQUIREMENTS
    rsync, ssh
HELPDOC
}; [ "$0" != "$BASH_SOURCE" ] && { print_help; return 0 ;}

## variables ::
remote='localhost'

# args:
flg_dryrun=false
flg_init=false
flg_pull=false
flg_push=false
flg_verbose=false
opt_config=
opt_dir=
opt_excludes=()
opt_port=
opt_remote=
opt_user=

# internal:
a=0 arg="$1" args=("$@") pargs=() opt=
args_rsync=(-azz --protect-args --info=copy1,del1,name1 --delete)
args_sed=(-e 's/deleting /\o033[1;38;5;9m - \o033[0;38;5;15m/'
    -e '/ - /! s/^/\o033[1;38;5;10m + \o033[0;38;5;15m/')
conf='.usync'
deps=(rsync ssh)
dir=
excludes=()
host="$HOSTNAME"
lines=()
n_cmds=0
port=
remote=
remote_dir=
user=

## functions ::
error() { msg_error "$@"; exit 5 ;}
is_cmd() { command -v "$1" &>/dev/null ;}

# print messages:
msg() { printf "\e[1;38;5;12m=> \e[0;38;5;15m$1\e[0m\n" "${@:2}" ;}
msg_cmd() {
    [ $EUID -eq 0 ] && printf '\e[1;38;5;9m #' || printf '\e[1;38;5;12m $'
    printf ' \e[0;38;5;15m'; for c in "${@:1:1}"; do printf '%q' "$c"; done
    for c in "${@:2}"; do printf ' %q' "$c"; done; printf '\e[0m\n'
}
msg_error() { printf "\e[1;38;5;9mE: \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2 ;}
msg_warn() { printf "\e[1;38;5;11mW: \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2 ;}

# parse args:
parse_flg() { arg="${args[((++a))]}" ;}
parse_opt() {
    [ ${#args[@]} -le $((a+1)) ] && error "arg required: $arg"
    opt="${args[((++a))]}"; arg="${args[((++a))]}"
}

## main ::
trap exit INT
while [ -n "$arg" ]; do case "$arg" in
    init) parse_flg; flg_init=true; ((n_cmds++)) ;;
    pull) parse_flg; flg_pull=true; ((n_cmds++)) ;;
    push) parse_flg; flg_push=true; ((n_cmds++)) ;;
    -D|--dryrun|--dry-run) parse_flg; flg_dryrun=true ;;
    -V|--verbose) parse_flg; flg_verbose=true ;;
    -H|--help) print_help; exit 0 ;;
    -c|--config) parse_opt; opt_config="$opt" ;;
    -d|--dir|--directory) parse_opt; opt_dir="$opt" ;;
    -e|--exclude) parse_opt; opt_excludes+=("$opt") ;;
    -p|--port) parse_opt; opt_port="$opt" ;;
    -r|--url|--remote) parse_opt; opt_remote="$opt" ;;
    -u|--user) parse_opt; opt_user="$opt" ;;
    -[DVH]*)
        [[ ! "${arg:2:1}" =~ [DVHcdepru] ]] && error "unknown option: ${arg:2:1}"
        args[a--]="-${arg:2}"; arg="${arg:0:2}" ;;
    -[cdepru]*) args[a]="${arg:2}"; arg="${arg:0:2}"; ((a--)) ;;
    --) ((a++)); break ;;
    *) break ;;
esac; done
pargs=("${args[@]:a}")

# dependency error:
for d in "${deps[@]}"; do is_cmd "$d" || error "missing dep: $d"; done

# args error:
[ ${#pargs[@]} -gt 0 ] && error "unknown args: ${pargs[*]}"
[ $n_cmds -eq 0 ] && msg_warn 'no command' && exit 9
[ $n_cmds -gt 1 ] && error 'too many commands'

# set config file from command line option:
conf="${opt_config:-$conf}"

if [ "$flg_init" = true ]; then
    # create new .usync file in current directory:
    [ -f "$conf" ] && error "already exists: $conf"
    touch "$conf"
    { printf '## %s ::\n\n' "$(realpath "$conf")"
    printf 'dir: %s\nurl: localhost\n\nexclude:\n- /local\n- .git\n\n' "$PWD"
    printf '# vim:ft=yaml\n' ;} > "$conf"
    exit 0
fi

# config file from command line option not found:
[ -n "$opt_conf" ] && [ ! -f "$conf" ] && error "file not found: $conf"

# cd to nearest parent directory that contains config file:
if [ -z "$opt_config" ]; then
    while [ ! -f "$conf" ] && [ "$PWD" != '/' ]; do cd ..; done
fi
[ ! -f "$conf" ] && error 'not a usync repository'

# parse config:
mapfile -t lines < <(sed -E -e 's/(^\s+|\s+$)//g' -e '/^(#|$|-$)/d' "$conf")
in_exclude=false
for l in "${lines[@]}"; do
    if [ "$in_exclude" = true ]; then
        [[ "$l" =~ ^-\ +(.*) ]] && excludes+=("${BASH_REMATCH[1]}") && continue
        in_exclude=false
    fi
    [[ "$l" =~ ^dir:\ +(.*) ]] && dir="${BASH_REMATCH[1]}" && continue
    [[ "$l" =~ ^port:\ +(.*) ]] && port="${BASH_REMATCH[1]}" && continue
    [[ "$l" =~ ^url:\ +(.*) ]] && remote="${BASH_REMATCH[1]}" && continue
    [[ "$l" =~ ^remote:\ +(.*) ]] && remote="${BASH_REMATCH[1]}" && continue
    [[ "$l" =~ ^user:\ +(.*) ]] && user="${BASH_REMATCH[1]}" && continue
    [ "$l" = 'exclude:' ] && in_exclude=true && continue
done

# set config from command line options:
dir="${opt_dir:-$dir}"
port="${opt_port:-$port}"
remote="${opt_remote:-$remote}"
user="${opt_user:-$user}"

# replace leading ~ with $HOME and remove trailing / from dir:
[ "${dir:0:1}" = '~' ] && dir="$HOME${dir:1}"
[ "${dir: -1}" = '/' ] && dir="${dir:0:-1}"

# config errors:
[ -z "$remote" ] && error 'no remote'
[ -z "$dir" ] && error 'no directory'
if [ -n "$port" ]; then
    if [[ ! $port =~ ^[1-9][0-9]*$ ]] || [ $port -gt 65535 ]; then
        error "invalid port: $port"
    fi
fi

# resolve host and remote:
[ -f '/etc/hostname' ] && host="$(cat /etc/hostname)"
[ -f '/etc/hostname-' ] && host="$(cat /etc/hostname-)"
[[ "$remote" =~ ^(|$host|127.0.0.1)$ ]] && remote='localhost'

# set remote_dir and add user/port to rsync ssh command:
remote_dir="$dir"
if [ "$remote" = 'localhost' ]; then
    # remote is a file:
    [ -f "$dir" ] && error "not a directory: $dir"
    # inside remote:
    if [ -d "$dir" ] && [ "$(realpath "$dir")" = "$(realpath "$PWD")" ]; then
        msg_warn 'remote repo: no action taken'
        exit 0
    fi
else
    remote_dir="$remote:$dir"
    if [ -n "$port" ] || [ -n "$user" ]; then
        args_rsync+=('-e' "ssh${port:+ -p $port}${user:+ -l $user}")
    fi
fi

# add excludes to rsync args:
for e in "${excludes[@]}"; do args_rsync+=('--exclude' "$e"); done
for e in "${opt_excludes[@]}"; do args_rsync+=('--exclude' "$e"); done

# add --dry-run to rsync args and set output color to yellow:
if [ "$flg_dryrun" = true ]; then
    args_rsync+=('--dry-run')
    args_sed=(-e 's/deleting /\o033[1;38;5;11m - \o033[0;38;5;15m/'
        -e '/ - /! s/^/\o033[1;38;5;11m + \o033[0;38;5;15m/')
fi

# set rsync push args:
if [ "$flg_push" = true ]; then
    msg 'pushing %q to %q ...' "$PWD/" "$remote_dir/"
    if [ "$remote" = 'localhost' ]; then
        # create local directory:
        if [ ! -d "$dir" ] && [ "$flg_dryrun" != true ]; then
            [ "$flg_verbose" = true ] && msg_cmd mkdir -p "$dir"
            mkdir -p "$dir"
        fi
    elif [ "$flg_dryrun" != true ]; then
        # create remote directory:
        args_rsync+=('--rsync-path' "mkdir -p '$dir' && rsync")
    fi
    args_rsync+=("$PWD/" "$remote_dir")

# set rsync pull args:
elif [ "$flg_pull" = true ]; then
    msg 'pulling %q from %q ...' "$PWD/" "$remote_dir/"
    args_rsync+=("$remote_dir/" "$PWD")
fi

# rsync:
[ "$flg_verbose" = true ] && msg_cmd rsync "${args_rsync[@]}"
rsync "${args_rsync[@]}" | sed -Ee '/\/$/d' -e '/^created /d' "${args_sed[@]}"

# dryrun warning:
[ "$flg_dryrun" = true ] && msg_warn 'dryrun'

# vim:ft=bash
