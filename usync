#!/bin/bash
## usync ::

print_help() { cat <<'HELPDOC'
NAME
    usync - push/pull changes from remote host

SYNOPSIS
    usync <command> [option...]

DESCRIPTION
    usync is an rsync wrapper configured by a basic yaml file. usync searches
    the current and parent directories for a file named .usync. The directory
    containing .usync is the local base working directory while the contents of
    .usync define a remote rsync host.

    usync forms an rsync command to push/pull the contents of the base working
    directory to/from the remote host using the rsync options: -azz --delete
    --protect-args. Exclude patterns may be added in .usync or via command
    line arguments.

COMMANDS
    init    Create a new .usync file in current directory.
    push    Push changes to remote rsync host.
    pull    Pull changes from remote rsync host.

OPTIONS
    -c, --config <file>         Set config file basename. (default: .usync)
    -d, --dir <directory>       Set remote rsync directory.
    -e, --exclude <pattern>     Add to rsync exclude patterns.
    -p, --port <port>           Set remote rsync port number.
    -r, --remote, --url <url>   Set remote rsync url. May be an ssh alias
    -u, --user <user>           Set remote rsync user.
    -D, --dryrun                Perform dry run making no changes.
    -Q, --quiet                 Don't write anything to stdout.
    -V, --verbose               Print more verbose information.
    --nocolor                   Disable colored output.
    -H, --help                  Print help.

CONFIG
    .usync - yaml file containing the following keys:
        dir             Remote repo directory. Must be a full path. (required)
        remote or url   Remote repo url. May be an ssh alias. (required)
        port            Remote port.
        user            Remote user.
        exclude         List of patterns excluded via rsync --exclude option.

ENVIRONMENT
    NOCOLOR=1   Disable colored output.
    QUIET=1     Run silently.
    VERBOSE=1   Run verbosely.
HELPDOC
}
[[ $0 != "${BASH_SOURCE[0]}" ]] && { print_help; return 0 ;}
[[ $1 =~ ^(-H|--help)$ ]] && { print_help; exit ;}

## settings ::
readonly -a deps=(rsync ssh)
readonly -a opts=(init pull push
    -c: --config: -d: --dir: -e: --exclude: -p: --port: -r: --remote: --url:
    -u: --user: -D --dryrun -Q --quiet -V --verbose --debug --nocolor -H --help)
DEBUG="${DEBUG:-0}"
NOCOLOR="${NOCOLOR:-0}"
QUIET="${QUIET:-0}"
VERBOSE="${VERBOSE:-0}"

## internal functions/variables ::
readonly -a args=("$@")
args_operands=() args_options=()
declare opt_dir opt_port opt_remote opt_user
init=0 pull=0 push=0 dryrun=0
dir= port= remote= user=
excludes=()
conf=.usync
host="$HOSTNAME"
in_exclude=0
remote_dir=
cmd_rsync=(rsync -azz --delete --protect-args '--info=copy1,del1,name1')
cmd_sed=(sed -Ee '/\/$/d' -e '/^created /d')

# colors:
blue=$'\e[38;5;12m'
bold=$'\e[1m'
green=$'\e[38;5;10m'
off=$'\e[0m'
red=$'\e[38;5;9m'
white=$'\e[38;5;15m'
yellow=$'\e[38;5;11m'
clear_colors() { unset blue bold green off red white yellow ;}

# messages:
msg() { ((QUIET)) || printf "$bold$blue=> $off$white$*$off\n" ;}
msg2() { ((QUIET)) || printf "$bold$blue > $off$white$*$off\n" ;}
msg_debug() { ((DEBUG)) && printf "${yellow}D: $off$*\n" >&2 ;}
msg_error() { printf "$bold${red}E: $off$white$*$off\n" >&2 ;}
msg_good() { ((QUIET)) || printf "$bold$green=> $off$white$*$off\n" ;}
msg_plain() { ((QUIET)) || printf "$off$white   $*$off\n" ;}
msg_warn() { printf "$bold${yellow}W: $off$white$*$off\n" >&2 ;}
msg_cmd() {
    ((QUIET)) && return
    [[ $EUID -eq 0 ]] && printf "$bold$red #" || printf "$bold$blue $"
    printf "$off$white"; "$cmd_printf" ' %q' "$@"; printf "$off\n"
}

# errors:
error() { msg_error "$@"; exit 3 ;}

# tests:
is_cmd() { command -v "$1" &>/dev/null ;}
is_port() { [[ $1 =~ ^[1-9][0-9]*$ && $1 -lt 65536 ]] ;}

# commands:
cmd_printf='printf'
[[ -f '/usr/bin/printf' ]] && cmd_printf='/usr/bin/printf'
exec_cmd() { ((VERBOSE)) && msg_cmd "$@"; "$@" ;}

# arg parser:
parse_args() {
    local a=0 opt= sflgs= sopts= arg="${args[0]}"
    local -a lflgs=() lopts=()
    bad_opt() { msg_error "unrecognized option: -${arg:2:1}" ;}
    bad_optarg() { msg_error "option requires an argument: $arg" ;}
    bad_flg() { msg_error "option does not take argument: ${arg%%=*}" ;}
    for opt in "${opts[@]}"; do case "$opt" in
        -?) sflgs="$sflgs${opt:1}" ;;
        -?:) sopts="$sopts${opt:1:1}" ;;
        *:) lopts+=("${opt:0:-1}") ;;
        *) lflgs+=("$opt") ;;
    esac; done
    while [[ -n $arg ]]; do case "$arg" in
        --) ((a++)); break ;;
        -[$sflgs]) args_options+=("$arg") ;;
        -[$sflgs]*) [[ ! $sflgs$sopts =~ ${arg:2:1} ]] && { bad_opt; return 3 ;}
            args_options+=("${arg:0:2}"); arg="-${arg:2}"; continue ;;
        -[$sopts]) [[ $((${#args[@]}-a)) -le 1 ]] && { bad_optarg; return 3 ;}
            args_options+=("$arg" "${args[((++a))]}") ;;
        -[$sopts]*) args_options+=("${arg:0:2}" "${arg:2}") ;;
        *=*) [[ " ${lflgs[*]} " =~ " ${arg%%=*} " ]] && { bad_flg; return 3 ;}
            [[ " ${lopts[*]} " =~ " ${arg%%=*} " ]] || break
            args_options+=("${arg%%=*}" "${arg#*=}") ;;
        *) if [[ " ${lflgs[*]} " =~ " $arg " ]]; then
                args_options+=("$arg")
            elif [[ " ${lopts[*]} " =~ " $arg " ]]; then
                [[ ${#args[@]} -le $((a+1)) ]] && { bad_optarg; return 3 ;}
                args_options+=("$arg" "${args[((++a))]}")
            else break; fi ;;
    esac; arg="${args[((++a))]}"; done
    args_operands=("${args[@]:a}")
}

## main ::
trap exit INT
((NOCOLOR)) || ! [[ -t 1 && -t 2 ]] && clear_colors

# parse args:
parse_args || exit
set -- "${args_options[@]}"
while [[ -n "$1" ]]; do case "$1" in
    init) init=1 ;;
    pull) pull=1 ;;
    push) push=1 ;;
    -c|--config) shift; conf="$1" ;;
    -d|--dir) shift; opt_dir="$1" ;;
    -e|--exclude) shift; excludes+=("$1") ;;
    -p|--port) shift; opt_port="$1" ;;
    -r|--url|--remote) shift; opt_remote="$1" ;;
    -u|--user) shift; opt_user="$1" ;;
    -D|--dryrun) dryrun=1 ;;
    -Q|--quiet) QUIET=1; VERBOSE=0 ;;
    -V|--verbose) QUIET=0; VERBOSE=1 ;;
    --debug) DEBUG=1 ;;
    --nocolor) clear_colors ;;
    -H|--help) print_help; exit 0 ;;
esac; shift; done

# errors:
for d in "${deps[@]}"; do is_cmd "$d" || error "missing dependency: $d"; done
[[ ${#args_operands[@]} -gt 0 ]] && error 'too many arguments'
((init+push+pull-1)) && error 'too many commands'
((init+push+pull)) || { msg_warn 'no command'; exit 0 ;}
[[ $conf =~ / ]] && error "config file name is not a basename: $conf"
[[ -z $conf ]] && error 'config file name cannot be blank'
[[ -n ${opt_dir+x} && -z $opt_dir ]] && error 'blank remote directory name'
[[ -n ${opt_remote+x} && -z $opt_remote ]] && error 'remote url cannot be blank'
[[ -z $opt_port ]] || is_port "$opt_port" || error "invalid port: $opt_port"

if ((init)); then
    # create new .usync file in current directory:
    [[ -f $conf ]] && error "already exists: $conf"
    touch "$conf"
    { printf '## %s ::\n\n' "$(realpath "$conf")"
    printf 'dir: %s\n' "${opt_dir:-$PWD}"
    printf 'url: %s\n' "${opt_remote:-localhost}"
    [[ -n "$opt_port" ]] && printf 'port: %s\n' "$opt_port"
    [[ -n "$opt_user" ]] && printf 'user: %s\n' "$opt_user"
    printf 'exclude:\n- .git\n- /local\n'
    for e in "${excludes[@]}"; do printf '%s %s\n' '-' "$e"; done
    printf '\n# vim:ft=yaml\n' ;} > "$conf"
    exit 0
fi

# cd to nearest parent directory that contains config file:
while [[ ! -f $conf && $PWD != / ]]; do cd ..; done
[[ ! -f $conf ]] && error "config not found: $conf"

# parse config:
# TODO: dedicated config/yaml parsing function
while read -r l; do
    if ((in_exclude)); then
        [[ $l =~ ^-\ +(.*) ]] && excludes+=("${BASH_REMATCH[1]}") && continue
        in_exclude=0
    fi
    [[ $l =~ ^dir:\ +(.*) ]] && dir="${BASH_REMATCH[1]}" && continue
    [[ $l =~ ^port:\ +(.*) ]] && port="${BASH_REMATCH[1]}" && continue
    [[ $l =~ ^url:\ +(.*) ]] && remote="${BASH_REMATCH[1]}" && continue
    [[ $l =~ ^remote:\ +(.*) ]] && remote="${BASH_REMATCH[1]}" && continue
    [[ $l =~ ^user:\ +(.*) ]] && user="${BASH_REMATCH[1]}" && continue
    [[ $l =~ exclude:\ * ]] && in_exclude=1 && continue
done < "$conf"
dir="${opt_dir:-$dir}"
port="${opt_port:-$port}"
remote="${opt_remote:-$remote}"
user="${opt_user:-$user}"

# replace leading ~ with $HOME and remove trailing / from dir:
[[ ${dir:0:1} == '~' ]] && dir="$HOME${dir:1}"
[[ ${dir: -1} == / && ${#dir} -gt 1 ]] && dir="${dir:0:-1}"

# config errors:
[[ -z $remote ]] && error 'no remote'
[[ -z $dir ]] && error 'no directory'
[[ -z $port ]] || is_port "$port" || error "invalid port: $port"

# resolve host and remote:
[[ -f /etc/hostname ]] && host="$(cat /etc/hostname)"
[[ -f /etc/hostname- ]] && host="$(cat /etc/hostname-)"
[[ $remote =~ ^(|$host|127.0.0.1)$ ]] && remote='localhost'

# debug info:
msg_debug "dir=$dir port=$port remote=$remote user=$user"
msg_debug "excludes=(${excludes[*]})"

# set remote_dir:
if [[ $remote == localhost ]]; then
    remote_dir="$dir"
    # dir is a file:
    [[ -f $dir ]] && error "not a directory: $dir"
    # inside remote:
    if [[ -d $dir && $(realpath "$dir") == $(realpath "$PWD") ]]; then
        msg_warn 'remote repo: no action taken'; exit 0
    fi
else
    remote_dir="$remote:$dir"
    # add user/port to rsync ssh command:
    if [[ -n $port || -n $user ]]; then
        cmd_rsync+=(-e "ssh${port:+ -p $port}${user:+ -l $user}")
    fi
fi

# add excludes to rsync args:
for e in "${excludes[@]}"; do cmd_rsync+=('--exclude' "$e"); done

if ((dryrun)); then
    # add --dry-run to rsync args and set output colors to yellow:
    cmd_rsync+=('--dry-run')
    cmd_sed+=(-e "s/deleting /$bold$yellow - $off$white/"
        -e "/ - /! s/^/$bold$yellow + $off$white/")
else
    # set output colors to green and red:
    cmd_sed+=(-e "s/deleting /$bold$red - $off$white/"
        -e "/ - /! s/^/$bold$green + $off$white/")
fi

# add rsync push/pull args:
if ((push)); then
    msg "pushing $PWD/ to $remote_dir/"
    if [[ "$remote" == localhost ]]; then
        # create local directory:
        ((dryrun)) || [[ -d $dir ]] || exec_cmd mkdir -p "$dir"
    elif ! ((dryrun)); then
        # create remote directory:
        cmd_rsync+=('--rsync-path' "mkdir -p '$dir' && rsync")
    fi
    cmd_rsync+=("$PWD/" "$remote_dir")
elif ((pull)); then
    msg "pulling $PWD/ from $remote_dir/"
    cmd_rsync+=("$remote_dir/" "$PWD")
fi

# rsync:
((VERBOSE)) && msg_cmd "${cmd_rsync[@]}"
if ((QUIET)); then
    "${cmd_rsync[@]}" 1>/dev/null
else
    "${cmd_rsync[@]}" | "${cmd_sed[@]}"
fi

# dryrun warning:
((dryrun)) && msg_warn 'dryrun'

# vim:ft=bash
