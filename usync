#!/bin/bash
## usync ::

print_help() {
cat <<'HELPDOC'
NAME
    usync - push/pull changes from remote source

SYNOPSIS
    usync <COMMAND> [OPTION...]

DESCRIPTION
    Usync is an rsync wrapper controlled via config file. Usync searches the
    current and parent directories for a .usync file and executes COMMAND.

COMMANDS
    init
        Create a new .usync file in current directory.

    push
        Push changes to remote source.

    pull
        Pull changes from remote source.

OPTIONS
    -c, --config <FILE>
        Use config FILE. Don't search parent dirs if FILE does not exist.

    -D, --dryrun
        Perform dry run making no changes.

    -V, --verbose
        Show rsync command.

    -H, --help
        Display this help.

CONFIG
    .usync - yaml file defining usync repo, may contain following keys:

        url
            Remote repo url. May be an ssh alias. Required.

        dir
            Remote directory. Must be a full path. Required.

        port
            Remote port. If blank, inherit from ssh alias.

        user
            Remote user. If blank, inherit from ssh alias.

        exclude
            List of patterns to exclude via rsync --exclude option.
            See FILTER RULES section of rsync manual.

REQUIREMENTS
    rsync, ssh, yq
HELPDOC
}

# TODO: list/query action

## internal control ::
a=0
arg="$1"
args=("$@")
args_rsync=('-azz' '--protect-args' '--info=copy1,del1,name1' '--delete')
arr_config=()
cfg_ssh=
cmd_ssh='ssh'
dir=
exclude=
excludes=()
file_config='.usync'
flg_dryrun=false
flg_init=false
flg_local=false
flg_pull=false
flg_push=false
flg_verbose=false
host="$HOSTNAME"
n_actions=0
opt_config=
port=
requirements=(rsync ssh yq)
url=
url_dir=
user=

if [ -f /etc/hostname- ]; then
    host="$(</etc/hostname-)"
elif [ -f /etc/hostname ]; then
    host="$(</etc/hostname)"
fi

## functions ::
msg() {
    printf "\e[1;38;5;12m==> \e[0;38;5;15m$1\e[0m\n" "${@:2}"
}

msg_error() {
    printf "\e[1;38;5;9mE: \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2
}

msg_warn() {
    printf "\e[1;38;5;11mW: \e[0;38;5;15m$1\e[0m\n" "${@:2}" >&2
}

msg_cmd() {
    local ps1=$'\e[1;38;5;10m'' :$'
    [ $EUID -eq 0 ] && ps1=$'\e[1;38;5;9m'' :#'
    printf '%s \e[0;38;5;15m%s\n' "$ps1" "$(printf '%q ' "$@")"
}

## main ::
while [ -n "$arg" ]; do case "$arg" in
    init)
        flg_init=true; arg="${args[((++a))]}"; ((n_actions++)) ;;
    pull)
        flg_pull=true; arg="${args[((++a))]}"; ((n_actions++)) ;;
    push)
        flg_push=true; arg="${args[((++a))]}"; ((n_actions++)) ;;
    -c|--config)
        [ $# -le $((a+1)) ] && msg_error "arg required: $arg" && exit 3
        opt_config="${args[((++a))]}"; arg="${args[((++a))]}" ;;
    -D|--dryrun)
        flg_dryrun=true; arg="${args[((++a))]}" ;;
    -V|--verbose)
        flg_verbose=true; arg="${args[((++a))]}" ;;
    -H|--help)
        print_help; exit 0 ;;
    -[DVH]*)
        if [[ ! "${arg:2:1}" =~ [DVHc] ]]; then
            msg_error "unknown option: ${arg:2:1}"; exit 3
        fi
        args[a--]="-${arg:2}"; arg="${arg:0:2}" ;;
    -[c]*)
        args[a]="${arg:2}"; arg="${arg:0:2}"; ((a--)) ;;
    --)
        ((a++)); break ;;
    *)
        break ;;
esac; done
args=("${args[@]:a}")

for req in "${requirements[@]}"; do if ! command -v "$req" &>/dev/null; then
    msg_error 'required: %s' "$req"
    exit 4
fi; done

if [ ${#args[@]} -gt 0 ]; then
    msg_error "unknown args: ${args[*]}"
    exit 3
fi

if [ $n_actions -eq 0 ] || [ $n_actions -gt 1 ]; then
    msg_error 'too many/no actions given'
    exit 3
fi

file_config="${opt_config:-$file_config}"

if [ "$flg_init" = true ]; then
    if [ -f "$file_config" ]; then
        msg_error "already exists: $file_config"
        exit 3
    fi
    touch "$file_config"
    { printf '## %s ::\n\n' "$(realpath "$file_config")"
    printf 'dir: %s\nurl: localhost\n\nexclude:\n- /local\n- .git\n\n' "$PWD"
    printf '# vim:ft=yaml\n' ;} > "$file_config"
    exit 0
fi

if [ -z "$opt_config" ]; then
    while [ ! -f "$file_config" ] && [ "$PWD" != '/' ]; do
        cd ..
    done
    if [ ! -f "$file_config" ]; then
        msg_error 'not a usync repository'
        exit 3
    fi

elif [ ! -f "$file_config" ]; then
    msg_error "file not found: $file_config"
    exit 3
fi

mapfile -t arr_config < <(yq -r \
'.dir//"", .port//"", .url//"", .user//"", .exclude[]' 2>/dev/null "$file_config")
if [ ${#arr_config[@]} -lt 4 ]; then
    msg_error "yaml error: $file_config"
    exit 3
fi
dir="${arr_config[0]}"
port="${arr_config[1]}"
url="${arr_config[2]}"
user="${arr_config[3]}"
excludes=("${arr_config[@]:4}")
[ "${dir:0:1}" = '~' ] && dir="$HOME${dir:1}"
[ "${dir: -1}" = '/' ] && dir="${dir:0:-1}"

if [ -z "$url" ]; then
    msg_error 'no url'
    exit 3
fi
if [ -z "$dir" ]; then
    msg_error 'no directory'
    exit 3
fi
if [ -n "$port" ]; then
    if [[ ! $port =~ ^[1-9][0-9]*$ ]] || [ "$port" -gt 65535 ]; then
        msg_error "invalid port: $port"
        exit 3
    fi
fi

if [[ "$url" =~ ^localhost|$host|127.0.0.1$ ]]; then
    flg_local=true
    if [ "$(realpath "$dir")" = "$(realpath "$PWD")" ]; then
        msg_warn 'remote: no action taken'
        exit 0
    fi
fi

if [ "$flg_local" != true ]; then
    cfg_ssh="$(ssh -G "$url")"
    if [ -n "$port" ] && [ "$(grep -Po '^port \K.*' <<<"$cfg_ssh")" != "$port" ]; then
        cmd_ssh+=" -p $port"
    fi
    if [ -n "$user" ] && [ "$(grep -Po '^user \K.*' <<<"$cfg_ssh")" != "$user" ]; then
        cmd_ssh+=" -l $user"
    fi
    if [ "$cmd_ssh" != 'ssh' ]; then
        args_rsync+=('-e' "$cmd_ssh")
    fi
fi

for exclude in "${excludes[@]}"; do
    args_rsync+=('--exclude' "$exclude")
done
[ "$flg_dryrun" = true ] && args_rsync+=('--dry-run')
[ "$flg_local" = true ] && url_dir="$dir" || url_dir="$url:$dir"

if [ "$flg_push" = true ]; then
    if [ "$flg_local" = true ]; then
        mkdir -p "$dir"
    else
        args_rsync+=('--rsync-path' "mkdir -p '$dir' && rsync")
    fi
    args_rsync+=("$PWD/" "$url_dir")
    msg "pushing %s to %s ..." "$(printf '%q' "$PWD/")" "$(printf '%q' "$url_dir/")"
fi

if [ "$flg_pull" = true ]; then
    args_rsync+=("$url_dir/" "$PWD")
    msg "pulling %s from %s ..." "$(printf '%q' "$PWD/")" "$(printf '%q' "$url_dir/")"
fi

[ "$flg_verbose" = true ] && msg_cmd rsync "${args_rsync[@]}"

rsync "${args_rsync[@]}" | sed -E -e '/\/$/d' -e '/^created /d' \
    -e 's/deleting /\o033[38;5;9m  - \o033[38;5;15m/' \
    -e '/  - /! s/^/\o033[38;5;10m  + \o033[38;5;15m/'

[ "$flg_dryrun" = true ] && msg_warn 'dry-run: no files synced'

# vim:ft=bash
